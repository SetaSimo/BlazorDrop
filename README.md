# BlazorDropSelect

`BlazorDropSelect` is a Blazor component for lazy-loading, searchable dropdowns with support for asynchronous data loading and virtual paging. It is styled using the Material design principles.

## Features

- Asynchronous data loading by pages
- Search by input text with debounce
- Scroll-to-end detection for infinite loading
- Value change binding
- Custom display selector

## Installation

1. Reference the component project or package in your Blazor Server or WebAssembly project.

2. Add the following to your `wwwroot/index.html` (Blazor WASM) or `_Host.cshtml` (Blazor Server):

```html
<script src="_content/BlazorDrop/BlazorDropSelect.js"></script>
<link rel="stylesheet" href="_content/BlazorDrop/BlazorDropSelect.css" />
<link href="https://fonts.googleapis.com/css2?family=Roboto&display=swap" rel="stylesheet">
```

## Usage

```razor
<BlazorDropSelect T="KeyValuePair<Guid, string>"
                  DisplaySelector="@(x => x.Value)"
                  OnLoadItemsAsync="LoadPageAsync"
                  OnSearchAsync="SearchForItemAsync"
                  OnValueChangedAsync="OnValueChanged"
                  CanShowLoadingIndicator="true"
                  Placeholder="Select value"
                  UpdateSearchDelayInMilliseconds="600"
                  PageSize="10"
                  ValueNotFoundMessageText="Value not found"
                  Value="@_selectedItem" />
```

### Parameters

| Parameter                   | Type                                | Description                                           |
|----------------------------|-------------------------------------|-------------------------------------------------------|
| `T`                        | `generic`                           | Type of the items in the dropdown                     |
| `Id`                       | `Guid`                              | Optional unique ID (auto-generated by default)        |
| `Class`                    | `string`                            | Optional CSS class for the component                  |
| `Placeholder`              | `string`                            | Placeholder text when nothing is selected             |
| `ValueNotFoundMessageText`| `string`                            | Message shown when no matching value is found         |
| `PageSize`                 | `int`                               | Number of items to load per page (default: 20)        |
| `CurrentPage`              | `int`                               | Current page index for paging (default: 0)            |
| `UpdateSearchDelayInMilliseconds` | `int`                      | Debounce delay for input search (default: 1000 ms)    |
| `Value`                    | `T`                                 | Currently selected item/ default value                               |
| `OnValueChangedAsync`             | `Func<T, Task<T>>`                  | Async callback triggered on selection change; should return the value to be assigned as selected                         |
| `DisplaySelector`          | `Func<T, string>`                   | Function to extract display text from item            |
| `OnLoadItemsAsync`      | `Func<int, int, Task<IEnumerable<T>>>` | Async method for loading paginated items          |
| `OnSearchAsync`   | `Func<string, Task<IEnumerable<T>>>`| Async method for searching items by text              |

### Example Code

```csharp
private Dictionary<Guid, string> _testValues = new();

private KeyValuePair<Guid, string> _selectedItem;

protected override async Task OnInitializedAsync()
{
    for (int i = 0; i < 1000; i++)
    {
        var id = Guid.NewGuid();
        _testValues.Add(id, $"Record {i}");
    }
}

private Task<IEnumerable<KeyValuePair<Guid, string>>> LoadPageAsync(int page, int pageSize)
{
    return Task.FromResult(_testValues.Skip(page * pageSize).Take(pageSize));
}

private Task<IEnumerable<KeyValuePair<Guid, string>>> SearchForItemAsync(string text)
{
    return Task.FromResult(_testValues.Where(x => x.Value.Contains(text)));
}

private Task<KeyValuePair<Guid, string>> OnValueChanged(KeyValuePair<Guid, string> item)
{
    _selectedItem = item;
    StateHasChanged();
    return Task.FromResult(_selectedItem);
}
```

## Notes

- Scroll detection triggers when the user reaches the bottom of the dropdown list.
- Click outside and scroll handlers are automatically attached and detached.
- This project currently targets **.NET Core 3.1**.
